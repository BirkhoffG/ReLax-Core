# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_explain.strategy.ipynb.

# %% ../nbs/03_explain.strategy.ipynb 2
from __future__ import annotations
from .import_essentials import *

# %% auto 0
__all__ = ['BaseStrategy', 'IterativeStrategy', 'VmapStrategy', 'PmapStrategy', 'BatchedVmapStrategy', 'BatchedPmapStrategy',
           'StrategyFactory']

# %% ../nbs/03_explain.strategy.ipynb 3
class BaseStrategy:
    """Base class for mapping strategy."""
    
    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        raise NotImplementedError
    
    __ALL__ = ["__call__"]


# %% ../nbs/03_explain.strategy.ipynb 4
class IterativeStrategy(BaseStrategy):
    """Iterativly generate counterfactuals."""

    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        
        assert X.ndim == 2
        cfs = jnp.stack([fn(X[i], pred_fn=pred_fn, **kwargs) for i in range(X.shape[0])])
        assert X.shape == cfs.shape
        return cfs


# %% ../nbs/03_explain.strategy.ipynb 5
class VmapStrategy(BaseStrategy):
    """Generate counterfactuals via `jax.vmap`."""

    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        
        assert X.ndim == 2
        partial_fn = partial(fn, pred_fn=pred_fn, **kwargs)
        cfs = jax.vmap(partial_fn)(X)
        return cfs


# %% ../nbs/03_explain.strategy.ipynb 6
def _pad_divisible_X(
    X: Array,
    n_devices: int
):
    """Pad `X` to be divisible by `n_devices`."""
    if X.shape[0] % n_devices != 0:
        pad_size = n_devices - X.shape[0] % n_devices
        X = jnp.concatenate([X, jnp.zeros((pad_size, *X.shape[1:]))])
    X_padded = X.reshape(n_devices, -1, *X.shape[1:])
    return X_padded


# %% ../nbs/03_explain.strategy.ipynb 8
class PmapStrategy(BaseStrategy):
    def __init__(
        self, 
        n_devices: int = None, # Number of devices. If None, use all available devices
        strategy: str = 'auto', # Strategy to generate counterfactuals
        **kwargs
    ):
        self.strategy = strategy
        self.n_devices = n_devices or jax.device_count()

    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        
        assert X.ndim == 2
        X_padded = _pad_divisible_X(X, self.n_devices)
        partial_fn = partial(fn, pred_fn=pred_fn, **kwargs)
        cfs = jax.pmap(jax.vmap(partial_fn))(X_padded)
        cfs = cfs.reshape(-1, *cfs.shape[2:])
        cfs = cfs[:X.shape[0]]
        return cfs


# %% ../nbs/03_explain.strategy.ipynb 9
def _batched_generation(
    gs_fn: Callable, # Generation strategy function
    cf_fn: Callable, # Function to generate cf for a single input
    X: Array, # Input instances to be explained
    pred_fn: Callable[[Array], Array],
    batch_size: int,
    **kwargs
) -> Array: # Generated counterfactual explanations
    """Batched  of counterfactuals."""
    
    assert X.ndim == 2, f"X must be a 2D array, got {X.ndim}D array"
    x_shape = X.shape
    batch_size = min(batch_size, x_shape[0])
    # pad X to be divisible by batch_size
    pad_size = batch_size - (X.shape[0] % batch_size)
    X = jnp.pad(X, ((0, pad_size), (0, 0)))
    X = X.reshape(-1, batch_size, *x_shape[1:])
    # generate cfs via lax.map
    gs_fn_partial = lambda x: gs_fn(cf_fn, x, pred_fn=pred_fn, **kwargs)
    cfs = lax.map(gs_fn_partial, X)
    cfs = cfs.reshape(-1, *x_shape[1:])[:x_shape[0]]
    return cfs
     


# %% ../nbs/03_explain.strategy.ipynb 10
class BatchedVmapStrategy(BaseStrategy):
    """Auto-batching for generate counterfactuals via `jax.vmap`."""
    def __init__(self, batch_size: int):
        self.batch_size = batch_size

    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        vmap_g = VmapStrategy()    
        cfs = _batched_generation(
            vmap_g, fn, X, pred_fn, self.batch_size, **kwargs
        )
        return cfs


# %% ../nbs/03_explain.strategy.ipynb 11
class BatchedPmapStrategy(BaseStrategy):
    """Auto-batching for generate counterfactuals via `jax.vmap`."""
    def __init__(self, batch_size: int, n_devices: int = None):
        self.batch_size = batch_size
        self.n_devices = n_devices

    def __call__(
        self, 
        fn: Callable, # Function to generate cf for a single input
        X: Array, # Input instances to be explained
        pred_fn: Callable[[Array], Array],
        **kwargs
    ) -> Array: # Generated counterfactual explanations
        pmap_g = PmapStrategy(self.n_devices)
        cfs = _batched_generation(
            pmap_g, fn, X, pred_fn, self.batch_size, **kwargs
        )
        return cfs


# %% ../nbs/03_explain.strategy.ipynb 20
class StrategyFactory(object):
    """Factory class for Parallelism Strategy."""

    __strategy_map = {
        'iter': IterativeStrategy(),
        'vmap': VmapStrategy(),
        'pmap': PmapStrategy(),
    }

    def __init__(self) -> None:
        raise ValueError("This class should not be instantiated.")
        
    @staticmethod
    def get_default_strategy() -> BaseStrategy:
        """Get default strategy."""
        return VmapStrategy()

    @classmethod
    def get_strategy(cls, strategy: str | BaseStrategy) -> BaseStrategy:
        """Get strategy."""
        if isinstance(strategy, BaseStrategy):
            return strategy
        elif isinstance(strategy, str) and strategy in cls.__strategy_map:
            return cls.__strategy_map[strategy]
        else:
            raise ValueError(f"Invalid strategy: {strategy}")
        
    __ALL__ = ["get_default_strategy", "get_strategy"]
